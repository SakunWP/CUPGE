# -*- coding: utf-8 -*-
"""Manipulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_bXfY62FswKHHZkE1f560qr64GCjW0IL
"""

######## I. Fonctions de base de manipulation d'arbres binaires vues en cours


class BinaryTree():
    def __init__(self,data,left=None,right=None):
      self.data =data
      self.left =left
      self.right =right
    
    def printTree(self):
      pr.printBTree(self,lambda n:(str(n.data),n.left,n.right)) 
    
    def child_left(self):
        return self.left
    
    def child_right(self):
        return self.right
    
    def racine(self):
        return self.data
    
    def empty_tree(self):
    	return (self.data!=None and self.left==None and self.right==None)




#### Nombre de noeuds dans l'arbre binaire ######
def nodes_tree (a):
    if a is None or a.empty_tree():
    	return 0
    else :
    	return(1+nodes_tree (a.child_left())+nodes_tree (a.child_right()))
      
#### Nombre de feuilles dans l'arbre binaire ######
def nb_feuille (a):
  if a is None :
    return 0
  if  a.empty_tree():
    return 1
  else :
    return(nb_feuille(a.child_left())+nb_feuille(a.child_right()))

#### Hauteur d'un arbre binaire ######
def height (a):
  if a is None :
    return 0
  else :
    return(1+max(height(a.child_left()), height(a.child_right())))


#### Valeur max d'un arbre binaire ######
def max_tree (a):
  if a is None :
    return -999999999999
  if a.empty_tree() :
      return a.racine()
  else :
      return max ( max(a.racine(),max_tree (a.child_left())), max(a.racine(),max_tree (a.child_right())) )


#### Vérifie si une valeur v appartient à un arbre binaire ######
def appartient(a,v):
  if a is None :
    return False   ##change into "0" for string keys
  if a.empty_tree() :
      return a.racine()==v
  else :
    return (a.racine()==v or appartient (a.child_left(),v) or appartient (a.child_right(),v))
    
          

#### Différents parcours prefixe, infixe et postfixe d'un arbre binaire ######
def parcours(a):
   if a is not None:
       #print (a.racine())  #prefixe
       parcours(a.left)
       #print (a.racine())  #infixe
       parcours(a.right)
       print (a.racine())  #postfixe



######## II. Fonctions de base de manipulation d'ABR vues en cours


### Vérifie si un arbre binaire est un arbre binaire de recherche ######
def isABR(a):
	if (a is None) :
	  return True
	if a.child_left() is not None and a.racine() <= (a.child_left()).racine():
	  return False
	if a.child_right() is not None and a.racine() > (a.child_right()).racine():
	  return False
	return (isABR(a.child_right()) and 
			isABR(a.child_left()))


### recherche d'une valeur val dans un ABR ######
def recherche_ABR (val,a):
  if a is None:
      return False
  if a.racine()==val:
  		return True
  else :
      if a.racine()<val:
      	return recherche_ABR(val,a.child_right())
      else: 
         return recherche_ABR(val,a.child_left())

### recherche de la valeur max dans un arbre binaire de recherche ######
def chercheMax (a): 
  p=a
  while (p.child_right() is not None) and (not (p.child_right()).empty_tree()):
    p=p.child_right()
  
  if p.right is None:
  	return p.racine()
  else:
  	return (p.right).racine()

### Insérer une valeur x dans un arbre binaire de recherche ######
def  ins(x,a) :
  if a is None: 
   a=BinaryTree(x)
  else :
    if a.racine() >=x:
      a.left=ins(x, a.child_left())
    else :
      a.right=ins(x, a.child_right())
  return(a)
  
  

### Trouvez le successeur d'un noeud dans un arbre binaire de recherche ######
def Successeur(noeud):
    courant = noeud
    while(courant.left is not None):
        courant = courant.left
    return courant


### Supprimer une valeur val dans un arbre binaire de recherche tout en reconstituant l'arbre résultat ######
def Supprimer(a, val):
    if a is None:
        return
 
    # si cle est inférieure à la valeur du noeud, rechercher dans le sous-arbre gauche
    if val < a.racine():
        a.left = Supprimer(a.child_left(),val)
 
    # si cle est supérieure à la valeur du noeud, rechercher dans le sous-arbre droit
    elif(val > a.racine()):
        a.right = Supprimer(a.child_right(),val)
 
    # sinon
    else:
 
        # noeud a un fils unique
        if a.left is None:
            temp = a.child_right()
            a = None
            return temp
 
        elif a.right is None:
            temp = a.child_righ()
            a = None
            return temp
 
        # noeud a deux enfants
        succ = Successeur(a.child_right())
 
        # le cas de prédécesseur
        # pred=Predecesseur(noeud.gauche)
 
        # remplacer la valeur du noeud à supprimer avec la valeur du successeur
        a.data = succ.racine()
 
        # supprimer le successeur
        a.right = Supprimer(a.child_right(), succ.racine())
 
        # le cas de prédecesseur
        #noeud.gauche = Supprimer(noeud.gauche, succ.val)
 
    return a